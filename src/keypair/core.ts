import { base58, base64url } from "@scure/base"
import { concatenate, type JWK, type JWKEC } from "@crumble-jon/ld-crypto-syntax"

import * as KEYPAIR_CONSTANT from "./constants.ts"
import { SuiteError } from "../error/error.ts"
import { SuiteErrorCode } from "../error/constants.ts"

type Flag = "private" | "public"

/**
 * Generate a Ed25519 keypair using the Web Crypto API.
 *
 * @returns {Promise<CryptoKeyPair>} Resolve to an Ed25519 keypair.
 */
export async function generateKeypair(): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey("Ed25519", true, ["sign", "verify"]) as CryptoKeyPair
}

/**
 * Calculate the key material from a CryptoKey instance. The flag determines if the key is private or public. It should
 * be noted that the key material generated by this function of both private key and public key are 32-octet arrays,
 * where the DER-encoded prefixes are removed.
 *
 * @param {CryptoKey} key A CryptoKey instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<Uint8Array>} Resolve to the key material.
 */
export async function keyToMaterial(key: CryptoKey, flag: Flag): Promise<Uint8Array> {
  const format = flag === "private" ? "pkcs8" : "spki"
  const expectedPrefix = flag === "private"
    ? KEYPAIR_CONSTANT.DER_PRIVATE_KEY_PREFIX
    : KEYPAIR_CONSTANT.DER_PUBLIC_KEY_PREFIX
  const exportedKey = await crypto.subtle.exportKey(format, key)
  const derPrefix = new Uint8Array(exportedKey.slice(0, expectedPrefix.length))
  if (!derPrefix.every((value, index) => value === expectedPrefix[index])) {
    throw new SuiteError(
      SuiteErrorCode.ENCODING_ERROR,
      "keypair/core.getKeyMaterial",
      `Expected the buffer to be a ED25519 ${flag} key!`,
    )
  }
  return new Uint8Array(exportedKey.slice(expectedPrefix.length))
}

/**
 * Recover a Ed25519 private or public key from the provided key material.
 *
 * @param {Uint8Array} material The 32-octet public or private key material in Uint8Array format.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to the recovered Ed25519 key in `CryptoKey` format.
 */
export async function materialToKey(material: Uint8Array, flag: Flag): Promise<CryptoKey> {
  const format = flag === "private" ? "pkcs8" : "spki"
  const prefix = flag === "private" ? KEYPAIR_CONSTANT.DER_PRIVATE_KEY_PREFIX : KEYPAIR_CONSTANT.DER_PUBLIC_KEY_PREFIX
  const buffer = concatenate(prefix, material)
  return await crypto.subtle.importKey(format, buffer, "Ed25519", true, flag === "private" ? ["sign"] : ["verify"])
}

/**
 * Encode a key material into a multibase-encoded string. It should be noted that the key material of private key is a
 * 64-octet array, where the first 32 octets denotes the private key and the last 32 octets denotes the public key.
 *
 * @param {Uint8Array} material The key material in Uint8Array format.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {string} The multibase-encoded key string.
 */
export function materialToMultibase(material: Uint8Array, flag: Flag): string {
  if (flag === "private" && material.length !== 64) {
    throw new SuiteError(
      SuiteErrorCode.FORMAT_ERROR,
      "keypair/core.materialToMultibase",
      "The private key material should be a 64-octet array!",
    )
  }
  if (flag === "public" && material.length !== 32) {
    throw new SuiteError(
      SuiteErrorCode.FORMAT_ERROR,
      "keypair/core.materialToMultibase",
      "The public key material should be a 32-octet array!",
    )
  }

  const multiPrefix = flag === "private"
    ? KEYPAIR_CONSTANT.MULTI_CODEC_PRIVATE_PREFIX
    : KEYPAIR_CONSTANT.MULTI_CODEC_PUBLIC_PREFIX

  const multibase = concatenate(multiPrefix, material)
  return KEYPAIR_CONSTANT.MULTIBASE_BASE58_BTC_PREFIX + base58.encode(multibase)
}

/**
 * Decode a multibase encoded private or public key into a Uint8Array key material, and check the key material against
 * the prefix from the specification. It should be noted that if the key is a private key, the decoded key material is
 * a 64-octet array, where the first 32 octets denotes the private key and the last 32 octets denotes the public key.
 *
 * @param {string} multibase A multibase-encoded private or public key string.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Uint8Array} The decoded key in Uint8Array format.
 */
export function multibaseToMaterial(multibase: string, flag: Flag): Uint8Array {
  if (!multibase.startsWith(KEYPAIR_CONSTANT.MULTIBASE_BASE58_BTC_PREFIX)) {
    throw new SuiteError(
      SuiteErrorCode.FORMAT_ERROR,
      "keypair/core.decodeMultibase",
      "Invalid multibase Base58 Bitcoin prefix!",
    )
  }
  const key = base58.decode(multibase.slice(KEYPAIR_CONSTANT.MULTIBASE_BASE58_BTC_PREFIX.length))
  const prefix = flag === "private"
    ? KEYPAIR_CONSTANT.MULTI_CODEC_PRIVATE_PREFIX
    : KEYPAIR_CONSTANT.MULTI_CODEC_PUBLIC_PREFIX
  prefix.forEach((value, index) => {
    if (key[index] !== value) {
      throw new SuiteError(
        SuiteErrorCode.DECODING_ERROR,
        "keypair/core.decodeMultibase",
        "The provided multibase string does not match the specified prefix!",
      )
    }
  })
  return key.slice(prefix.length)
}

/**
 * Convert a `CryptoKey` instance into a `JWKEC` key object. The flag determines if the key is private or public. When
 * the key is private, the `d` field is included in the JWK object.
 *
 * @param {CryptoKey} key A `CryptoKey` instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<JWKEC>} Resolve to an object representing a JSON Web Key.
 */
export async function keyToJwk(key: CryptoKey, flag: Flag): Promise<JWKEC> {
  const jwk = await crypto.subtle.exportKey("jwk", key)
  return {
    kty: jwk.kty || "OKP",
    use: jwk.use || "sig",
    key_ops: jwk.key_ops,
    alg: jwk.alg || "Ed25519",
    ext: jwk.ext || true,
    crv: jwk.crv || "Ed25519",
    x: jwk.x || "",
    y: "",
    d: flag === "private" ? jwk.d! : undefined,
  }
}

/**
 * Convert a `JWKEC` key object into a `CryptoKey` instance. The flag determines if the key is private or public. When
 * the key is private, the `d` field MUST be provided in the `jwk` input.
 *
 * @param {JWKEC} jwk An object representing a JSON Web Key.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to a `CryptoKey` instance.
 */
export async function jwkToKey(jwk: JWKEC, flag: Flag): Promise<CryptoKey> {
  const usage = jwk.key_ops || (flag === "private" ? ["sign"] : ["verify"])
  const secret = flag === "private" ? jwk.d : undefined

  if (flag === "private" && !secret) {
    throw new SuiteError(
      SuiteErrorCode.DECODING_ERROR,
      "keypair/core.jwkToKey",
      "The private key material is missing from the JWK object!",
    )
  }

  const prepare = {
    kty: jwk.kty,
    crv: jwk.crv,
    key_ops: usage,
    ext: jwk.ext || true,
    x: jwk.x,
    y: "",
    d: secret,
  }

  return await crypto.subtle.importKey("jwk", prepare, "Ed25519", true, usage as KeyUsage[])
}

/**
 * Calculate the thumbprint of a JWK instance using SHA-256 hash algorithm.
 *
 * @param {JWK} jwk A JSON Web Key instance.
 * @returns {Promise<string>} Resolve to the thumbprint of the JWK instance.
 */
export async function getJwkThumbprint(jwk: JWK): Promise<string> {
  const data = new TextEncoder().encode(JSON.stringify(jwk))
  const hash = await crypto.subtle.digest("SHA-256", data)
  return base64url.encode(new Uint8Array(hash))
}
