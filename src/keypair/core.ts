import { base58, base64url } from "@scure/base"
import {
  concatenate,
  type JWK,
  type JWKEC,
  type KeypairDocument,
  toW3CTimestampString,
} from "@crumble-jon/ld-crypto-syntax"

import * as CONTEXT_URL from "../context/constants.ts"
import * as KEYPAIR_CONSTANT from "./constants.ts"
import * as SUITE_CONSTANT from "../suite/constants.ts"
import { SuiteError } from "../error/error.ts"
import { SuiteErrorCode } from "../error/constants.ts"
import { Ed25519Keypair } from "./keypair.ts"

type Flag = "private" | "public"

/**
 * Generate a Ed25519 keypair using the Web Crypto API.
 *
 * @returns {Promise<CryptoKeyPair>} Resolve to an Ed25519 keypair.
 */
export async function generateKeypair(): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(SUITE_CONSTANT.ALGORITHM, true, ["sign", "verify"]) as CryptoKeyPair
}

/**
 * Calculate the key material from a CryptoKey instance. The flag determines if the key is private or public. It should
 * be noted that the key material generated by this function of both private key and public key are 32-octet arrays,
 * where the DER-encoded prefixes are removed.
 *
 * @param {CryptoKey} key A CryptoKey instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<Uint8Array>} Resolve to the key material.
 */
export async function keyToMaterial(key: CryptoKey, flag: Flag): Promise<Uint8Array> {
  const format = flag === "private" ? KEYPAIR_CONSTANT.PRIVATE_FORMAT : KEYPAIR_CONSTANT.PUBLIC_FORMAT
  const expectedPrefix = flag === "private" ? KEYPAIR_CONSTANT.DER_PRIVATE_PREFIX : KEYPAIR_CONSTANT.DER_PUBLIC_PREFIX
  const exportedKey = await crypto.subtle.exportKey(format, key)
  const derPrefix = new Uint8Array(exportedKey.slice(0, expectedPrefix.length))
  if (!derPrefix.every((value, index) => value === expectedPrefix[index])) {
    throw new SuiteError(
      SuiteErrorCode.ENCODING_ERROR,
      "keypair/core.getKeyMaterial",
      `Expected the buffer to be a Ed25519 ${flag} key!`,
    )
  }
  return new Uint8Array(exportedKey.slice(expectedPrefix.length))
}

/**
 * Recover a Ed25519 private or public key from the provided key material.
 *
 * @param {Uint8Array} material The 32-octet public or private key material in Uint8Array format.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to the recovered Ed25519 key in `CryptoKey` format.
 */
export async function materialToKey(material: Uint8Array, flag: Flag): Promise<CryptoKey> {
  const format = flag === "private" ? KEYPAIR_CONSTANT.PRIVATE_FORMAT : KEYPAIR_CONSTANT.PUBLIC_FORMAT
  const prefix = flag === "private" ? KEYPAIR_CONSTANT.DER_PRIVATE_PREFIX : KEYPAIR_CONSTANT.DER_PUBLIC_PREFIX
  const buffer = concatenate(prefix, material)
  return await crypto.subtle.importKey(
    format,
    buffer,
    SUITE_CONSTANT.ALGORITHM,
    true,
    flag === "private" ? ["sign"] : ["verify"],
  )
}

/**
 * Encode a key material into a multibase-encoded string. It should be noted that the key material of private key is a
 * 64-octet array, where the first 32 octets denotes the private key and the last 32 octets denotes the public key.
 *
 * @param {Uint8Array} material The key material in Uint8Array format.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {string} The multibase-encoded key string.
 */
export function materialToMultibase(material: Uint8Array, flag: Flag): string {
  if (flag === "private" && material.length !== KEYPAIR_CONSTANT.LENGTH_PRIVATE_KEY) {
    throw new SuiteError(
      SuiteErrorCode.FORMAT_ERROR,
      "keypair/core.materialToMultibase",
      "The private key material should be a 64-octet array!",
    )
  }
  if (flag === "public" && material.length !== KEYPAIR_CONSTANT.LENGTH_PUBLIC_KEY) {
    throw new SuiteError(
      SuiteErrorCode.FORMAT_ERROR,
      "keypair/core.materialToMultibase",
      "The public key material should be a 32-octet array!",
    )
  }

  const multiPrefix = flag === "private"
    ? KEYPAIR_CONSTANT.MULTIBASE_PRIVATE_PREFIX
    : KEYPAIR_CONSTANT.MULTIBASE_PUBLIC_PREFIX

  const multibase = concatenate(multiPrefix, material)
  return KEYPAIR_CONSTANT.MULTIBASE_BASE58_BTC_PREFIX + base58.encode(multibase)
}

/**
 * Decode a multibase encoded private or public key into a Uint8Array key material, and check the key material against
 * the prefix from the specification. It should be noted that if the key is a private key, the decoded key material is
 * a 64-octet array, where the first 32 octets denotes the private key and the last 32 octets denotes the public key.
 *
 * @param {string} multibase A multibase-encoded private or public key string.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Uint8Array} The decoded key in Uint8Array format.
 */
export function multibaseToMaterial(multibase: string, flag: Flag): Uint8Array {
  if (!multibase.startsWith(KEYPAIR_CONSTANT.MULTIBASE_BASE58_BTC_PREFIX)) {
    throw new SuiteError(
      SuiteErrorCode.FORMAT_ERROR,
      "keypair/core.decodeMultibase",
      "Invalid multibase Base58 Bitcoin prefix!",
    )
  }
  const key = base58.decode(multibase.slice(KEYPAIR_CONSTANT.MULTIBASE_BASE58_BTC_PREFIX.length))
  const prefix = flag === "private"
    ? KEYPAIR_CONSTANT.MULTIBASE_PRIVATE_PREFIX
    : KEYPAIR_CONSTANT.MULTIBASE_PUBLIC_PREFIX
  prefix.forEach((value, index) => {
    if (key[index] !== value) {
      throw new SuiteError(
        SuiteErrorCode.DECODING_ERROR,
        "keypair/core.decodeMultibase",
        "The provided multibase string does not match the specified prefix!",
      )
    }
  })
  return key.slice(prefix.length)
}

/**
 * Convert a `CryptoKey` instance into a `JWKEC` key object. The flag determines if the key is private or public. When
 * the key is private, the `d` field is included in the JWK object.
 *
 * @param {CryptoKey} key A `CryptoKey` instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<JWKEC>} Resolve to an object representing a JSON Web Key.
 */
export async function keyToJwk(key: CryptoKey, flag: Flag): Promise<JWKEC> {
  const jwk = await crypto.subtle.exportKey("jwk", key)
  return {
    kty: jwk.kty || KEYPAIR_CONSTANT.JWK_DEFAULT_TYPE,
    use: jwk.use || KEYPAIR_CONSTANT.JWK_DEFAULT_USE,
    key_ops: jwk.key_ops,
    alg: jwk.alg || SUITE_CONSTANT.ALGORITHM,
    ext: jwk.ext || true,
    crv: jwk.crv || SUITE_CONSTANT.ALGORITHM,
    x: jwk.x || "",
    y: "",
    d: flag === "private" ? jwk.d! : undefined,
  }
}

/**
 * Convert a `JWKEC` key object into a `CryptoKey` instance. The flag determines if the key is private or public. When
 * the key is private, the `d` field MUST be provided in the `jwk` input.
 *
 * @param {JWKEC} jwk An object representing a JSON Web Key.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to a `CryptoKey` instance.
 */
export async function jwkToKey(jwk: JWKEC, flag: Flag): Promise<CryptoKey> {
  const usage = jwk.key_ops || (flag === "private" ? ["sign"] : ["verify"])
  const secret = flag === "private" ? jwk.d : undefined

  if (flag === "private" && !secret) {
    throw new SuiteError(
      SuiteErrorCode.DECODING_ERROR,
      "keypair/core.jwkToKey",
      "The private key material is missing from the JWK object!",
    )
  }

  const prepare = {
    kty: jwk.kty,
    crv: jwk.crv,
    key_ops: usage,
    ext: jwk.ext || true,
    x: jwk.x,
    y: "",
    d: secret,
  }

  return await crypto.subtle.importKey("jwk", prepare, SUITE_CONSTANT.ALGORITHM, true, usage as KeyUsage[])
}

/**
 * Export a keypair instance into a `KeypairDocument` object containing a keypair in JWK format.
 *
 * @param {Ed25519Keypair} keypair An Ed25519 keypair instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<KeypairDocument>} Resolve to a `KeypairDocument` object.
 */
export async function keypairToJwk(keypair: Ed25519Keypair, flag: Flag): Promise<KeypairDocument> {
  const document: KeypairDocument = {
    "@context": CONTEXT_URL.JWS_2020,
    id: keypair.id!,
    controller: keypair.controller!,
    type: KEYPAIR_CONSTANT.TYPE_JWK,
    revoked: keypair.revoked ? toW3CTimestampString(keypair.revoked) : undefined,
  }

  if (flag === "public") {
    document.publicKeyJwk = await keyToJwk(keypair.publicKey!, "public")
    document.id = `${keypair.controller!}#${await getJwkThumbprint(document.publicKeyJwk!)}`
  } else {
    document.privateKeyJwk = await keyToJwk(keypair.privateKey!, "private")
    document.id = `${keypair.controller!}#${await getJwkThumbprint(document.privateKeyJwk!)}`
  }
  return document
}

/**
 * Import a keypair from a serialized `KeypairDocument` object containing a keypair in JWK format.
 *
 * @param {KeypairDocument} document An externally fetched key document.
 * @param {Date} revoked The revoked date of the keypair.
 *
 * @returns {Promise<Ed25519Keypair>} Resolve to a keypair instance.
 */
export async function jwkToKeypair(document: KeypairDocument, revoked?: Date): Promise<Ed25519Keypair> {
  const keypair = new Ed25519Keypair(document.id, document.controller, revoked)

  if (document.privateKeyJwk) {
    // private key
    const jwk = document.privateKeyJwk as JWKEC
    const jwkCopy = { ...jwk }
    delete jwkCopy.d
    jwkCopy.key_ops = ["verify"]
    keypair.privateKey = await jwkToKey(jwk, "private")
    keypair.publicKey = await jwkToKey(jwkCopy, "public")
  } else if (document.publicKeyJwk) {
    // public key only
    const jwk = document.publicKeyJwk as JWKEC
    keypair.publicKey = await jwkToKey(jwk, "public")
  } else {
    throw new SuiteError(
      SuiteErrorCode.DECODING_ERROR,
      "Ed25519Keypair.import",
      "The key material is missing from the JWK object!",
    )
  }

  return keypair
}

/**
 * Export a keypair instance into a `KeypairDocument` object containing a keypair in multibase format.
 *
 * @param {Ed25519Keypair} keypair An Ed25519 keypair instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<KeypairDocument>} Resolve to a `KeypairDocument` object.
 */
export async function keypairToMultiBase(keypair: Ed25519Keypair, flag: Flag): Promise<KeypairDocument> {
  const document: KeypairDocument = {
    "@context": CONTEXT_URL.SUITE_2020,
    id: keypair.id!,
    controller: keypair.controller!,
    type: keypair.type,
    revoked: keypair.revoked ? toW3CTimestampString(keypair.revoked) : undefined,
  }

  if (flag === "public") {
    document.publicKeyMultibase = await keypair.getPublicKeyMultibase()
  } else {
    document.secretKeyMultibase = await keypair.getPrivateKeyMultibase()
  }

  return document
}

/**
 * Import a keypair from a serialized `KeypairDocument` object containing a keypair in multibase format.
 *
 * @param {KeypairDocument} document An externally fetched key document.
 * @param {Date} revoked The revoked date of the keypair.
 *
 * @returns {Promise<Ed25519Keypair>} Resolve to a keypair instance.
 */
export async function multibaseToKeypair(document: KeypairDocument, revoked?: Date): Promise<Ed25519Keypair> {
  const keypair = new Ed25519Keypair(document.id, document.controller, revoked)

  if (document.secretKeyMultibase) {
    const combinedMaterial = multibaseToMaterial(document.secretKeyMultibase!, "private")
    const length = KEYPAIR_CONSTANT.LENGTH_PRIVATE_KEY - KEYPAIR_CONSTANT.LENGTH_PUBLIC_KEY
    const privateKeyMaterial = combinedMaterial.slice(0, length)
    const publicKeyMaterial = combinedMaterial.slice(length)
    keypair.privateKey = await materialToKey(privateKeyMaterial, "private")
    keypair.publicKey = await materialToKey(publicKeyMaterial, "public")
  } else if (document.publicKeyMultibase) {
    const publicKeyMaterial = multibaseToMaterial(document.publicKeyMultibase!, "public")
    keypair.publicKey = await materialToKey(publicKeyMaterial, "public")
  } else {
    throw new SuiteError(
      SuiteErrorCode.DECODING_ERROR,
      "Ed25519Keypair.import",
      "The key material is missing from the multibase object!",
    )
  }

  return keypair
}

/**
 * Calculate the thumbprint of a JWK instance using SHA-256 hash algorithm.
 *
 * @param {JWK} jwk A JSON Web Key instance.
 * @returns {Promise<string>} Resolve to the thumbprint of the JWK instance.
 */
async function getJwkThumbprint(jwk: JWK): Promise<string> {
  const data = new TextEncoder().encode(JSON.stringify(jwk))
  const hash = await crypto.subtle.digest("SHA-256", data)
  return base64url.encode(new Uint8Array(hash))
}
