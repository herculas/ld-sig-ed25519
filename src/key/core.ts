import { base58, base64url } from "@scure/base"
import { concatenate, type JWK, type JWKEC, type KeyFlag } from "@herculas/vc-data-integrity"

import { SuiteError } from "../error/error.ts"
import { ErrorCode } from "../error/constants.ts"
import * as KEY_CONSTANT from "../constants/key.ts"
import * as PREFIX_CONSTANT from "../constants/prefix.ts"
import * as SUITE_CONSTANT from "../constants/suite.ts"

/**
 * Generate a Ed25519 keypair using the Web Crypto API.
 *
 * @returns {Promise<CryptoKeyPair>} Resolve to an Ed25519 keypair.
 */
export async function generateKeypair(): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(SUITE_CONSTANT.ALGORITHM, true, ["sign", "verify"]) as CryptoKeyPair
}

/**
 * Calculate the key material from a CryptoKey instance. The flag determines if the key is private or public. It should
 * be noted that the key material generated by this function of both private key and public key are 32-octet arrays,
 * where the DER-encoded prefixes are removed.
 *
 * @param {CryptoKey} key A CryptoKey instance.
 * @param {KeyFlag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<Uint8Array>} Resolve to the key material.
 */
export async function keyToMaterial(key: CryptoKey, flag: KeyFlag): Promise<Uint8Array> {
  const format = flag === "private" ? KEY_CONSTANT.FORMAT_PRIVATE : KEY_CONSTANT.FORMAT_PUBLIC
  const expectedPrefix = flag === "private" ? PREFIX_CONSTANT.DER_PRIVATE : PREFIX_CONSTANT.DER_PUBLIC
  const exportedKey = await crypto.subtle.exportKey(format, key)
  const derPrefix = new Uint8Array(exportedKey.slice(0, expectedPrefix.length))
  if (!derPrefix.every((value, index) => value === expectedPrefix[index])) {
    throw new SuiteError(
      ErrorCode.ENCODING_ERROR,
      "keypair/core.getKeyMaterial",
      `Expected the buffer to be a Ed25519 ${flag} key!`,
    )
  }
  return new Uint8Array(exportedKey.slice(expectedPrefix.length))
}

/**
 * Recover a Ed25519 private or public key from the provided key material.
 *
 * @param {Uint8Array} material The 32-octet public or private key material in Uint8Array format.
 * @param {KeyFlag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to the recovered Ed25519 key in `CryptoKey` format.
 */
export async function materialToKey(material: Uint8Array, flag: KeyFlag): Promise<CryptoKey> {
  const format = flag === "private" ? KEY_CONSTANT.FORMAT_PRIVATE : KEY_CONSTANT.FORMAT_PUBLIC
  const prefix = flag === "private" ? PREFIX_CONSTANT.DER_PRIVATE : PREFIX_CONSTANT.DER_PUBLIC
  const buffer = concatenate(prefix, material)
  return await crypto.subtle.importKey(
    format,
    buffer,
    SUITE_CONSTANT.ALGORITHM,
    true,
    flag === "private" ? ["sign"] : ["verify"],
  )
}

/**
 * Encode a key material into a multibase-encoded string. It should be noted that the key material of private key is a
 * 64-octet array, where the first 32 octets denotes the private key and the last 32 octets denotes the public key.
 *
 * @param {Uint8Array} material The key material in Uint8Array format.
 * @param {KeyFlag} flag The flag to determine if the key is private or public.
 *
 * @returns {string} The multibase-encoded key string.
 */
export function materialToMultibase(material: Uint8Array, flag: KeyFlag): string {
  if (flag === "private" && material.length !== KEY_CONSTANT.LENGTH_PRIVATE) {
    throw new SuiteError(
      ErrorCode.FORMAT_ERROR,
      "keypair/core.materialToMultibase",
      `The private key material should be a ${KEY_CONSTANT.LENGTH_PRIVATE}-octet array!`,
    )
  }
  if (flag === "public" && material.length !== KEY_CONSTANT.LENGTH_PUBLIC) {
    throw new SuiteError(
      ErrorCode.FORMAT_ERROR,
      "keypair/core.materialToMultibase",
      `The public key material should be a ${KEY_CONSTANT.LENGTH_PUBLIC}-octet array!`,
    )
  }

  const multiPrefix = flag === "private" ? PREFIX_CONSTANT.MULTIBASE_PRIVATE : PREFIX_CONSTANT.MULTIBASE_PUBLIC

  const multibase = concatenate(multiPrefix, material)
  return PREFIX_CONSTANT.BASE_58_BTC + base58.encode(multibase)
}

/**
 * Decode a multibase encoded private or public key into a Uint8Array key material, and check the key material against
 * the prefix from the specification. It should be noted that if the key is a private key, the decoded key material is
 * a 64-octet array, where the first 32 octets denotes the private key and the last 32 octets denotes the public key.
 *
 * @param {string} multibase A multibase-encoded private or public key string.
 * @param {KeyFlag} flag The flag to determine if the key is private or public.
 *
 * @returns {Uint8Array} The decoded key in Uint8Array format.
 */
export function multibaseToMaterial(multibase: string, flag: KeyFlag): Uint8Array {
  // check the initial `Z` prefix for base-58-btc encoding
  if (!multibase.startsWith(PREFIX_CONSTANT.BASE_58_BTC)) {
    throw new SuiteError(
      ErrorCode.FORMAT_ERROR,
      "keypair/core.decodeMultibase",
      "Invalid multibase Base58 Bitcoin prefix!",
    )
  }
  const key = base58.decode(multibase.slice(PREFIX_CONSTANT.BASE_58_BTC.length))

  // check the multibase prefix for public or private key
  const prefix = flag === "private" ? PREFIX_CONSTANT.MULTIBASE_PRIVATE : PREFIX_CONSTANT.MULTIBASE_PUBLIC
  prefix.forEach((value, index) => {
    if (key[index] !== value) {
      throw new SuiteError(
        ErrorCode.DECODING_ERROR,
        "keypair/core.decodeMultibase",
        "The provided multibase string does not match the specified prefix!",
      )
    }
  })

  return key.slice(prefix.length)
}

/**
 * Convert a `CryptoKey` instance into a `JWKEC` key object. The flag determines if the key is private or public. When
 * the key is private, the `d` field is included in the JWK object.
 *
 * @param {CryptoKey} key A `CryptoKey` instance.
 * @param {KeyFlag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<JWKEC>} Resolve to an object representing a JSON Web Key.
 */
export async function keyToJwk(key: CryptoKey, flag: KeyFlag): Promise<JWKEC> {
  const jwk = await crypto.subtle.exportKey("jwk", key)
  return {
    kty: jwk.kty || KEY_CONSTANT.JWK_TYPE,
    use: jwk.use || KEY_CONSTANT.JWK_USE,
    key_ops: jwk.key_ops,
    alg: jwk.alg || SUITE_CONSTANT.ALGORITHM,
    ext: jwk.ext || true,
    crv: jwk.crv || SUITE_CONSTANT.ALGORITHM,
    x: jwk.x || "",
    y: "",
    d: flag === "private" ? jwk.d! : undefined,
  }
}

/**
 * Convert a `JWKEC` key object into a `CryptoKey` instance. The flag determines if the key is private or public. When
 * the key is private, the `d` field MUST be provided in the `jwk` input.
 *
 * @param {JWKEC} jwk An object representing a JSON Web Key.
 * @param {KeyFlag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to a `CryptoKey` instance.
 */
export async function jwkToKey(jwk: JWKEC, flag: KeyFlag): Promise<CryptoKey> {
  const usage = jwk.key_ops || (flag === "private" ? ["sign"] : ["verify"])
  const secret = flag === "private" ? jwk.d : undefined

  if (flag === "private" && !secret) {
    throw new SuiteError(
      ErrorCode.DECODING_ERROR,
      "keypair/core.jwkToKey",
      "The private key material is missing from the JWK object!",
    )
  }

  const prepare = {
    kty: jwk.kty,
    crv: jwk.crv,
    key_ops: usage,
    ext: jwk.ext || true,
    x: jwk.x,
    y: "",
    d: secret,
  }

  return await crypto.subtle.importKey("jwk", prepare, SUITE_CONSTANT.ALGORITHM, true, usage as KeyUsage[])
}

/**
 * Calculate the thumbprint of a JWK instance using SHA-256 hash algorithm.
 *
 * @param {JWK} jwk A JSON Web Key instance.
 * @returns {Promise<string>} Resolve to the thumbprint of the JWK instance.
 */
export async function getJwkThumbprint(jwk: JWK): Promise<string> {
  const data = new TextEncoder().encode(JSON.stringify(jwk))
  const hash = await crypto.subtle.digest("SHA-256", data)
  return base64url.encode(new Uint8Array(hash))
}
